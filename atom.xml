<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FIRE Blog</title>
  
  <subtitle>编程杂谈</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kangtian.coding.me/"/>
  <updated>2018-10-07T08:55:38.540Z</updated>
  <id>http://kangtian.coding.me/</id>
  
  <author>
    <name>kangtian.poon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【剑指offer】 复杂链表的赋值</title>
    <link href="http://kangtian.coding.me/2018/09/18/listclone/"/>
    <id>http://kangtian.coding.me/2018/09/18/listclone/</id>
    <published>2018-09-18T10:45:27.000Z</published>
    <updated>2018-10-07T08:55:38.540Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;####题目描述&lt;br&gt;输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）&lt;br&gt;算法实现思路：虽然是复杂链表
        
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://kangtian.coding.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="list" scheme="http://kangtian.coding.me/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>【剑指offer】 二叉树中和为某值的路径</title>
    <link href="http://kangtian.coding.me/2018/09/18/treetarget/"/>
    <id>http://kangtian.coding.me/2018/09/18/treetarget/</id>
    <published>2018-09-18T09:18:02.000Z</published>
    <updated>2018-10-07T08:55:38.717Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;####题目描述：&lt;br&gt;输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意:
        
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://kangtian.coding.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="tree" scheme="http://kangtian.coding.me/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>【剑指offer】 栈的压入弹出序列</title>
    <link href="http://kangtian.coding.me/2018/09/18/stackpushpop/"/>
    <id>http://kangtian.coding.me/2018/09/18/stackpushpop/</id>
    <published>2018-09-18T08:58:38.000Z</published>
    <updated>2018-10-07T08:55:38.695Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;####题目描述：&lt;br&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该
        
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://kangtian.coding.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="stack" scheme="http://kangtian.coding.me/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>【剑指offer】 构建含有min函数的栈</title>
    <link href="http://kangtian.coding.me/2018/09/18/minstack/"/>
    <id>http://kangtian.coding.me/2018/09/18/minstack/</id>
    <published>2018-09-18T07:56:20.000Z</published>
    <updated>2018-10-07T08:55:38.605Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;####题目描述：&lt;br&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import
        
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://kangtian.coding.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="stack" scheme="http://kangtian.coding.me/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>【剑指offer】 顺时针打印二维数组</title>
    <link href="http://kangtian.coding.me/2018/09/18/printArray/"/>
    <id>http://kangtian.coding.me/2018/09/18/printArray/</id>
    <published>2018-09-18T07:49:05.000Z</published>
    <updated>2018-10-07T08:55:38.610Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1.输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
        
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://kangtian.coding.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="array" scheme="http://kangtian.coding.me/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>JAVA排序算法--快速排序和归并排序</title>
    <link href="http://kangtian.coding.me/2018/09/17/sortqm/"/>
    <id>http://kangtian.coding.me/2018/09/17/sortqm/</id>
    <published>2018-09-17T06:50:08.000Z</published>
    <updated>2018-10-07T08:55:38.673Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1.快速排序算法    &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原理：  快速排序由C. A. R.
        
      
    
    </summary>
    
      <category term="Java工具" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/"/>
    
      <category term="排序算法" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="sort" scheme="http://kangtian.coding.me/tags/sort/"/>
    
      <category term="排序" scheme="http://kangtian.coding.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA排序算法--堆排序</title>
    <link href="http://kangtian.coding.me/2018/09/17/sortheap/"/>
    <id>http://kangtian.coding.me/2018/09/17/sortheap/</id>
    <published>2018-09-17T06:50:08.000Z</published>
    <updated>2018-10-07T08:55:38.656Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;堆排序算法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能
        
      
    
    </summary>
    
      <category term="Java工具" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/"/>
    
      <category term="排序算法" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="sort" scheme="http://kangtian.coding.me/tags/sort/"/>
    
      <category term="排序" scheme="http://kangtian.coding.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA排序算法--直接插入排序和希尔排序</title>
    <link href="http://kangtian.coding.me/2018/09/17/sortinsertshell/"/>
    <id>http://kangtian.coding.me/2018/09/17/sortinsertshell/</id>
    <published>2018-09-17T02:39:31.000Z</published>
    <updated>2018-10-07T08:55:38.666Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1.直接插入排序算法&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原理：&lt;br&gt;  
        
      
    
    </summary>
    
      <category term="Java工具" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/"/>
    
      <category term="排序算法" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="sort" scheme="http://kangtian.coding.me/tags/sort/"/>
    
      <category term="排序" scheme="http://kangtian.coding.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA排序算法--选择排序和冒泡排序</title>
    <link href="http://kangtian.coding.me/2018/09/14/sortsb/"/>
    <id>http://kangtian.coding.me/2018/09/14/sortsb/</id>
    <published>2018-09-14T07:02:06.000Z</published>
    <updated>2018-10-07T08:55:38.686Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1.选择排序算法&lt;br&gt;选择排序算法原理：选择排序算法就是在集合中选择最大或则最小的数，将其放在集合前列，然后循环剩下的集合数据，重复寻找最大或最小值。选择排序算法是不稳定的算法&lt;br&gt;我们可以简单的依次选择剩下元素中的最小值，将其跟i处的值交换，从而达到排序的效果，不管数
        
      
    
    </summary>
    
      <category term="Java工具" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/"/>
    
      <category term="排序算法" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="sort" scheme="http://kangtian.coding.me/tags/sort/"/>
    
      <category term="排序" scheme="http://kangtian.coding.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>httpclient</title>
    <link href="http://kangtian.coding.me/2018/08/29/httpclient/"/>
    <id>http://kangtian.coding.me/2018/08/29/httpclient/</id>
    <published>2018-08-29T08:13:14.000Z</published>
    <updated>2018-10-07T08:55:38.523Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;为了应付在web项目中调用其他http或https接口的需求，本文根据 &lt;a href=&quot;https://blog.csdn.net/tianya3530/article/details/77337124&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
      <category term="Java工具" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="http" scheme="http://kangtian.coding.me/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>MD5加密工具</title>
    <link href="http://kangtian.coding.me/2018/08/28/md5/"/>
    <id>http://kangtian.coding.me/2018/08/28/md5/</id>
    <published>2018-08-28T12:56:00.000Z</published>
    <updated>2018-10-07T08:55:38.584Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;pre&gt;&lt;code&gt;public static  String getMd5(String str) throws NoSuchAlgorithmException {
       char hex[] = { //用于混淆 可自定义
          
        
      
    
    </summary>
    
      <category term="Java工具" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://kangtian.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="加密" scheme="http://kangtian.coding.me/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>验证码生成工具</title>
    <link href="http://kangtian.coding.me/2018/08/28/codeutil/"/>
    <id>http://kangtian.coding.me/2018/08/28/codeutil/</id>
    <published>2018-08-28T12:56:00.000Z</published>
    <updated>2018-10-07T08:55:38.494Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;本验证码生成采用的是Google提供的第三方KAPTCHA服务，使用及其方便，使用步骤分为以下三步：&lt;br&gt;1.添加依赖  在pom.xml文件中添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
      
        
      
    
    </summary>
    
      <category term="Java工具" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://kangtian.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="验证码" scheme="http://kangtian.coding.me/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>文件处理类</title>
    <link href="http://kangtian.coding.me/2018/08/28/fileutil/"/>
    <id>http://kangtian.coding.me/2018/08/28/fileutil/</id>
    <published>2018-08-28T12:56:00.000Z</published>
    <updated>2018-10-07T08:55:38.511Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1.生成文件名，避免文件重复&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static String getRandomFileName() {
    // 生成随机文件名：当前年月日时分秒+五位随机数（为了在实际项目中防止文件同名而进行的处理）
    int
        
      
    
    </summary>
    
      <category term="Java工具" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://kangtian.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="文件" scheme="http://kangtian.coding.me/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>DES加密工具</title>
    <link href="http://kangtian.coding.me/2018/08/28/desutil/"/>
    <id>http://kangtian.coding.me/2018/08/28/desutil/</id>
    <published>2018-08-28T12:56:00.000Z</published>
    <updated>2018-10-07T08:55:38.501Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;本工具采用的是DES SHA1PRNG 加密，如有兴趣，读者可由此自定义其他加密工具。具体可看代码注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.io.IOException;
import
        
      
    
    </summary>
    
      <category term="Java工具" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://kangtian.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="加密" scheme="http://kangtian.coding.me/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>seo工具</title>
    <link href="http://kangtian.coding.me/2018/08/28/sitemaputil/"/>
    <id>http://kangtian.coding.me/2018/08/28/sitemaputil/</id>
    <published>2018-08-28T12:56:00.000Z</published>
    <updated>2018-10-07T08:55:38.648Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;Sitemaps定义：&quot;&gt;&lt;a href=&quot;#Sitemaps定义：&quot; class=&quot;headerlink&quot; title=&quot;Sitemaps定义：&quot;&gt;&lt;/a&gt;&lt;a
        
      
    
    </summary>
    
      <category term="Java工具" scheme="http://kangtian.coding.me/categories/Java%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://kangtian.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="SEO" scheme="http://kangtian.coding.me/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>【剑指offer】  输出倒数第k个结点以及逆转指针</title>
    <link href="http://kangtian.coding.me/2018/08/21/listNode/"/>
    <id>http://kangtian.coding.me/2018/08/21/listNode/</id>
    <published>2018-08-21T11:16:15.000Z</published>
    <updated>2018-10-07T08:55:38.530Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1、输入一个链表，输出该链表中倒数第k个结点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ListNode FindKthToTail(ListNode head,int k) {
    ListNode tem=head;//缓根节点
    while
        
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://kangtian.coding.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="array" scheme="http://kangtian.coding.me/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>【剑指offer】  重排数组</title>
    <link href="http://kangtian.coding.me/2018/08/21/reOrderArray/"/>
    <id>http://kangtian.coding.me/2018/08/21/reOrderArray/</id>
    <published>2018-08-21T11:16:15.000Z</published>
    <updated>2018-10-07T08:55:38.638Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1、输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void reOrderArray(int []
        
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://kangtian.coding.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="array" scheme="http://kangtian.coding.me/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>【剑指offer】 斐波那契数列问题</title>
    <link href="http://kangtian.coding.me/2018/08/21/JumpFloor/"/>
    <id>http://kangtian.coding.me/2018/08/21/JumpFloor/</id>
    <published>2018-08-21T11:16:15.000Z</published>
    <updated>2018-10-07T08:55:38.469Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1、&lt;a href=&quot;https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin&quot; title=&quot;斐波那契数列&quot;
        
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://kangtian.coding.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="math" scheme="http://kangtian.coding.me/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>【剑指offer】  统计二进制1与指数的实现</title>
    <link href="http://kangtian.coding.me/2018/08/21/math/"/>
    <id>http://kangtian.coding.me/2018/08/21/math/</id>
    <published>2018-08-21T11:16:15.000Z</published>
    <updated>2018-10-07T08:55:38.564Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1、输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static   int  NumberOf1(int n) { //例如10101
  int count=0;
  while (n!=0){
     
        
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://kangtian.coding.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="math" scheme="http://kangtian.coding.me/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>【剑指offer】  树的遍历</title>
    <link href="http://kangtian.coding.me/2018/08/21/treeTraver/"/>
    <id>http://kangtian.coding.me/2018/08/21/treeTraver/</id>
    <published>2018-08-21T11:16:15.000Z</published>
    <updated>2018-10-07T08:55:38.710Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1、利用递归的方式获取树的前序遍历结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //获取树的前序遍历
public static String preTraver(TreeNode root){
    if (root!=null) {
        re +=
        
      
    
    </summary>
    
      <category term="数据结构" scheme="http://kangtian.coding.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="tree" scheme="http://kangtian.coding.me/tags/tree/"/>
    
  </entry>
  
</feed>
