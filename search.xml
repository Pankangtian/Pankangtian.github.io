<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql使用指南]]></title>
    <url>%2F2018%2F10%2F22%2Fmysql%2F</url>
    <content type="text"><![CDATA[一、 mysql的yum安装本文的mysql 安装基于 centos 7 系统，仅供参考 执行安装mysql命令 yum install mysql mysql-server mysql-devel -y 如果安装过程中有选择，选择 是或y即可 启动和关闭mysql启动 mysql命令 systemctl start mysqld (centos 7) service mysqld start （centos 6) 关闭mysql命令 systemctl stop mysqld (centos 7) service mysqld stop （centos 6) 重启mysql systemctl restart mysqld (centos 7) service mysqld restart （centos 6) 加入开机自启动 systemctl enable mysqld (centos 7) service mysqld enable （centos 6) 二、配置mysql 设置密码 mysqladmin -u root password &apos;你的密码&apos; 检查密码设置通过mysql -u root -p 命令登陆mysql 查看刚设置的密码是否生效mysql -u root -p 忘记密码，后重置密码首先停止sql服务，具体命令查看mysql的yum安装部分其次通过不检查权限形式启动mysql ,此时mysql可以无密登陆 mysqld --skip-grant-tables 登陆mysql，运行sql语句修改root密码mysql&gt; UPDATE mysql.user SET Password=PASSWORD(&apos;123456&apos;) WHERE User=&apos;root&apos;; mysql&gt; FLUSH PRIVILEGES; 运行后，重启mysql服务器即可，密码已改为新设置密码。 mysql配置文件my.ini 文件详解文件详细配置不再详述，详情可点击此处 三、mysql 语句 表的创建]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO模式探究]]></title>
    <url>%2F2018%2F10%2F07%2Fio%2F</url>
    <content type="text"><![CDATA[IO模式探究 一、五种I/O模型 &nbsp;&nbsp;为什么IO操作要发起系统调用？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程无法直接获取硬盘的数据，硬盘的数据只能通过内核获取。所谓的系统调用即是进程通知内核说我要磁盘中的数据，你帮我把数据读写了。 IO具体过程如下：&nbsp;&nbsp;&nbsp;&nbsp; ①进程向内核发起一个系统调用，&nbsp;&nbsp;&nbsp;&nbsp; ②内核接收到系统调用，知道是对文件的请求，于是告诉磁盘，把文件读取出来&nbsp;&nbsp;&nbsp;&nbsp; ③磁盘接收到来着内核的命令后，把文件载入到内核的内存空间里面&nbsp;&nbsp;&nbsp;&nbsp; ④内核的内存空间接收到数据之后，把数据copy到用户进程的内存空间(此过程是I/O发生的地方)&nbsp;&nbsp;&nbsp;&nbsp; ⑤进程内存空间得到数据后，给内核发送通知 &nbsp;&nbsp;&nbsp;&nbsp; ⑥内核把接收到的通知回复给进程，此过程为唤醒进程，然后进程得到数据，进行下一步操作 一、 IO五模型 阻塞I/0 当进程调用阻塞型IO时，进程必须等待系统完成所有调用才能进行自己的工作。在系统进行调用期间，进程只能让出cpu时间片，处于睡眠状态，直到系统通知进程唤醒。其图解如下： 非阻塞I/O 系统知道自己需要一定时间完成IO操作，所以就让进程发起调用后，先去做自己的事情，而不是阻塞等待。进程每隔一段时间后需要询问系统调用是否完成，如果未完成，系统会立即返回错误，如EWOULDBLOCK，直至系统调用完成，进程获取数据（忙等待） I/O复用 I/O复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符（FileDescription，简称FD），如果有一个或多个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后，进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。 事件(信号)驱动I/O (1)水平触发的事件驱动机制；内核通知进程来读取数据，进程没来读取数据，内核需要一次一次的通知进程；(2)边缘触发的事件驱动机制；内核只通知一次让进程来读取数据，进程可以在超时时间之内随时来读取数据。 异步I/O 当现线程遇到IO操作时，线程不去处理IO而是交由工作线程处理，不会处于阻塞状态，转而继续处理自己的事情，当IO操作完成后，工作线程会通知当前线程，由当前线程做出相应处理。 二、同步与异步，阻塞与非阻塞 同步阻塞IO：设备IO忙时，内核对发起IO请求的进程说：“现在设备忙，你别走开，在这里等吧，你看IO什么时候做完，做完了你把数据拿走就是了”发起IO请求的进程说：“好，那我在这等你” 同步非阻塞IO：设备IO忙时，内核对发起IO请求的进程说：“我已经知道你要IO了，但设备现在有点忙，你回家吧，我会记住你这个事的，我有记录呢，只要设备一空闲我就给你做IO的，做完了给你打电话让你过来拿数据”发起IO请求的进程说：“IO还没做完呢，我不走，我要不断的问我的IO什么时候完成，知道你把我的IO做完为止” 异步阻塞IO：设备IO忙时，内核对发起IO请求的进程说：“现在设备忙，你别走开，在这里等吧，你看IO什么时候做完，做完了你把数据拿走就是了”发起IO请求的进程说：“哦，您忙吧，我在这里排队等着呢，不过我排队时也无聊，就做做其他的事情吧，我会时不时就看看我的IO做完没有的” 异步非阻塞IO：设备IO忙时，内核对发起IO请求的进程说：“我已经知道你要IO了，但设备现在有点忙，你回家吧，我会记住你这个事的，我有记录呢，只要设备一空闲我就给你做IO的，做完了给你打电话让你过来拿数据”发起IO请求的进程说：“好吧，您看我事也挺多的，既然现在IO一时半会也完成不了，那我先回家去做做其他的事吧，谢谢啊” 总结：阻塞/非阻塞是内核级的，同步/异步是进程级的，同步非阻塞和异步阻塞一般不会采用，异步非阻塞一般效率比较高，他能够把cpu和io并行处理，当然，如果没有cpu和io并行的这种情况，那就用同步阻塞比较好，这样编程比较简单，且不用多次在内核空间和用户空间进行切换 [1] Partially Reproduced]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 复杂链表的赋值]]></title>
    <url>%2F2018%2F09%2F18%2Flistclone%2F</url>
    <content type="text"><![CDATA[####题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）算法实现思路：虽然是复杂链表，但还是可以跟简单链表一个思路，先备份头结点，然后复制简单链表，最后根据原链表同步复制随机指针，为了便捷的找到指针，我采用hashmap用于查询节点，从而快速找到节点位置 public RandomListNode Clone(RandomListNode pHead) { HashMap&lt;Integer,RandomListNode&gt; data= new HashMap&lt;&gt;();//用于复制随机指针时快速定位到指针位置 if (pHead==null) return null; RandomListNode tempPHead=pHead; RandomListNode head, tempHead, foot; foot=new RandomListNode(pHead.label); data.put(pHead.label,foot); head=foot; //拷贝简单的链表 while (pHead!=null){ pHead=pHead.next; foot.next=new RandomListNode(pHead.label); foot=foot.next; data.put(pHead.label,foot);//保存复制出来的节点索引 } tempHead=head; //拷贝random while (tempPHead!=null){ if (tempPHead.random!=null){ tempHead.random= data.get(tempPHead.random.label);//获取节点索引 } tempHead=tempHead.next; tempPHead=tempPHead.next; } return head; }]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 二叉树中和为某值的路径]]></title>
    <url>%2F2018%2F09%2F18%2Ftreetarget%2F</url>
    <content type="text"><![CDATA[####题目描述：输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)利用前序遍历，遍历所有节点，利用target减为零和子节点是否都空判断是不是叶子节点 private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists; /** * 题目描述 * 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。 * 路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 * (注意: 在返回值的list中，数组长度大的数组靠前) * @param root * @param target * @return */ public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) { arrayLists=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); FindPath(root,target,&quot;&quot;); return arrayLists; } //递归遍历各节点，并利用String 统计路径，当满足target==0 &amp;root.left==null&amp;root.right==null，路径和为target，且为叶子节点 public void FindPath(TreeNode root, int target,String path) { if (root!=null) { path += root.val+&quot;,&quot;;//记录路径 target=target-root.val;//和为target，即target减其为0 if (target==0 &amp;root.left==null&amp;root.right==null){//root.left==null&amp;root.right==null为判断其是否叶子节点 ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;(); String[] st = path.split(&quot;,&quot;); for (int i=0;i&lt;st.length;i++)//将路径添加到list中 arrayList.add(Integer.valueOf(st[i])); arrayLists.add(arrayList); } if (target&lt;0)//当小于零时，则其以下节点不用考虑 return ; if (root.left != null) FindPath(root.left,target,path); if (root.right != null) FindPath(root.right,target,path); } }]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 栈的压入弹出序列]]></title>
    <url>%2F2018%2F09%2F18%2Fstackpushpop%2F</url>
    <content type="text"><![CDATA[####题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路：我们可以根据根据弹出序列的值来判断是否执行出栈操作，当循环完后，压入序列未出栈完，则认为该弹出序列不是该压栈序列的弹出序列。 static ArrayList&lt;Integer&gt; stack = new ArrayList&lt;Integer&gt;(); public static boolean IsPopOrder(int[] pushA, int[] popA) { int len = pushA.length; int i = 0; int k = 0; while (i &lt; len) { stack.add(pushA[i]);//将序列压入栈中 if (pushA[i] == popA[k]) {//当栈顶元素等于弹出序列k的值时，说明是栈顶元素出栈了 stack.remove((Integer) pushA[i]); k++; i++; }else//否则继续压栈操作 i++; while ((stack.size()&gt;0&amp;&amp;stack.get(stack.size()-1) == popA[k])) {//当栈顶元素等于弹出序列k的值时，说明是栈顶元素该出栈了 stack.remove(stack.size() - 1);//执行出栈操作 k++; } } if (stack.size()==0)//所有元素入栈且出栈完，说明其是弹出序列 return true; else return false; }]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 构建含有min函数的栈]]></title>
    <url>%2F2018%2F09%2F18%2Fminstack%2F</url>
    <content type="text"><![CDATA[####题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 import java.util.ArrayList; /**采用两个链表，一个链表存储数据，另一个链表存储用于存储最小值 * 比如dataList为5 4 7 3 2 ，则minList为5 4 4 3 2 。 * 当执行pop操作时，再同步删除两个链表的值，维护数据 * 5 4 7 3 5 4 4 3 * @param node */ public class MinStack { ArrayList&lt;Integer&gt; dataList=new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; minList=new ArrayList&lt;Integer&gt;(); private int min=Integer.MAX_VALUE; public void push(int node) {//对于最小栈，始终保持同步存入最小的数 dataList.add(node); if (min&gt;node){//如果最小值大于node，存储node minList.add(node); min=node; }else { minList.add(min);//否则存储min } } public int pop() {//同时出栈，维护栈的数据 int size=dataList.size(); minList.remove(size-1); return dataList.remove(size-1); } public int top() { return dataList.get(dataList.size()-1); } public int min() { return minList.get(minList.size()-1); } }]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 顺时针打印二维数组]]></title>
    <url>%2F2018%2F09%2F18%2FprintArray%2F</url>
    <content type="text"><![CDATA[1.输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路：对于矩阵的瞬时针打印，我们可以认为其属于轮循的分别执行打印各边，从而降低问题的难度。 /** * 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： * 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. */ public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) { int rows=matrix.length; int cols=matrix[0].length; ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;(rows*cols); int rowstart=0,rowend=rows-1,colstart=0,colend=cols-1; if (rows==1) { for (int i = 0; i &lt;= colend; i++) arrayList.add(matrix[0][i]); return arrayList; } if (cols==1) { for (int i = 0; i &lt;= rowend; i++) arrayList.add(matrix[i][0]); return arrayList; } /**顺时针打印矩阵，即意味着可以将矩阵看为一圈又一圈数字组成。 * 一圈又分为四边，可以分为四个循环，注意各点边界 */ while (rowstart&lt;=rowend&amp;colstart&lt;=colend){ for (int i=colstart;i&lt;=colend;i++)//打印上边 arrayList.add(matrix[rowstart][i]); for (int i=rowstart+1;i&lt;=rowend;i++)//打印右边 arrayList.add(matrix[i][colend]); for (int i=colend-1;i&gt;=colstart&amp;rowstart!=rowend;i--)////打印右边 （当rows小于cols时，会出现重复打印。故需加上判断） arrayList.add(matrix[rowend][i]); for (int i=rowend-1;i&gt;rowstart;i--)//打印左边 arrayList.add(matrix[i][colstart]); rowstart++;rowend--;colstart++;colend--; } return arrayList; }]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA排序算法--堆排序]]></title>
    <url>%2F2018%2F09%2F17%2Fsortheap%2F</url>
    <content type="text"><![CDATA[堆排序算法： 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了 因此堆排序算法是一个不断将堆顶元素取出，并重新构建堆的过程。其算法实现如下： public void sort(int arr[]){ int len=arr.length; for (int i=0;i&lt;len;i++) { adjust(arr, len - 1 - i);//构建堆 swap(arr, 0, len - i - 1);//把堆顶元素取出 } int i=0,end=arr.length-1; while (i&lt;end){ swap(arr,i,end); i++;end--; } } 1.堆的父类 /** *堆是一组元素按照完全二叉树的形式存储在一个数组里面，并且在这个完全二叉树里面满足父节点和子节点的关系为 * Ki &lt;= K2*i+1 且 Ki&lt;= K2*i+2(或Ki &gt;= K2*i+1 且 Ki &gt;= K2*i+2) i = 0，1，2…， 的一种数据结构。 */ public class Heap { int size=0,len=16;double capacity=1.5; int [] heap; public Heap(){ heap=new int[len]; } public Heap(int len){ this.len=len; heap=new int[len]; } public Heap(int len,int capacity){ this.len=len; this.capacity=capacity; heap=new int[len]; } public int peek(){ return heap[0]; } public void printHeap(){ for (int i=0;i&lt;size;i++) System.out.print(heap[i]+&quot; , &quot;); System.out.println(); } public static void swap(int arr[],int a,int b){ int tem=arr[a]; arr[a]=arr[b]; arr[b]=tem; } public int pop(){ int tem=heap[0]; heap[0]=heap[size-1]; size--; adjust(heap,size-1); return size; } public void adjust(int heap[] ,int end){ } public boolean isEmpty(){ return size==0; } public boolean isFull(){ return size==len; } public static boolean isHeap( int[] arr){ boolean is=true; int len=arr.length-1; if (len&lt;=1) return is; if (arr[0]&lt;arr[1]) for(int i=(len-1)/2;i&gt;=0;i--){ int k=i;//k对应树的根节点 while(k*2+1&lt;=len){ int j=2*k+1;//对应子节点 if(j&lt;len&amp;&amp;arr[j]&gt;arr[j+1]) j++; if(arr[k]&gt;arr[j]){//判断根节点是否大于子节点，如果是，则不满足小堆 is=false;i=-1; break; } else { k=j; } } } else for(int i=(len-1)/2;i&gt;=0;i--){ int k=i; while(k*2+1&lt;=len){ int j=2*k+1; if(j&lt;len&amp;&amp;arr[j]&gt;arr[j+1]) j++; if(arr[k]&lt;arr[j]){//判断根节点是否小于父节点，如果是，则不满足大堆 is=false;i=-1; break; }else{ k=j; } } } return is; } } 2.最大堆 public class MaxHeap extends Heap { public MaxHeap(){ heap=new int[len]; } public MaxHeap(int len){ this.len=len; heap=new int[len]; } public MaxHeap(int len,int capacity){ this.len=len; this.capacity=capacity; heap=new int[len]; } public MaxHeap(int [] arr){ len=arr.length; heap=new int[len]; for (int i=0;i&lt;len;i++) { insert(arr[i]); } } public void insert(int num) { if (isFull()){ len=(int) (len*capacity); int tem[] =new int[len]; for (int i=0;i&lt;size;i++) tem[i]=heap[i]; heap=tem; } int i = size;//指向插入元素后堆中的最后一个元素的位置 for(;i&gt;0 &amp;&amp; heap[(i-1)/2]&lt;num;i=(i-1)/2){ heap[i] = heap[(i-1)/2]; } heap[i] = num; size++; } //调整数组，使其保持堆的性质 @Override public void adjust(int heap[] ,int end){ for(int i=(end-1)/2;i&gt;=0;i--){ int k=i;//根节点 while(k*2+1&lt;=end){ int j=2*k+1; if(j&lt;end){ if(heap[j]&lt;heap[j+1]){ j++; } } if(heap[k]&lt;heap[j]){//判断 swap(heap,k,j); k=j; }else{ break; } } } } public void sort(int arr[]){ int len=arr.length; for (int i=0;i&lt;len;i++) { adjust(arr, len - 1 - i); swap(arr, 0, len - i - 1); } } } 3.最小堆 public class MinHeap extends Heap { public MinHeap(){ heap=new int[len]; } public MinHeap(int len){ this.len=len; heap=new int[len]; } public MinHeap(int len,int capacity){ this.len=len; this.capacity=capacity; heap=new int[len]; } public MinHeap(int [] arr){ len=arr.length; heap=new int[len]; for (int i=0;i&lt;len;i++) { insert(arr[i]); } } public void insert(int num) { if (isFull()){ len=(int) (len*capacity); int tem[] =new int[len]; for (int i=0;i&lt;size;i++) tem[i]=heap[i]; heap=tem; } int i = size;//指向插入元素后堆中的最后一个元素的位置 for(;i&gt;0 &amp;&amp; heap[(i-1)/2]&gt;num;i=(i-1)/2){ heap[i] = heap[(i-1)/2]; } heap[i] = num; size++; } public void adjust(int heap[] ,int end){ for(int i=(end-1)/2;i&gt;=0;i--){ int k=i; while(k*2+1&lt;=end){ int j=2*k+1; if(j&lt;end){ if(heap[j]&gt;heap[j+1]){ j++; } } if(heap[k]&gt;heap[j]){ swap(heap,k,j); k=j; }else{ break; } } } } public void sort(){ sort(heap); } public void sort(int arr[]){ int len=arr.length; for (int i=0;i&lt;len;i++) { adjust(arr, len - 1 - i); swap(arr, 0, len - i - 1); } int i=0,end=arr.length-1; while (i&lt;end){ swap(arr,i,end); i++;end--; } } }]]></content>
      <categories>
        <category>Java工具</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA排序算法--快速排序和归并排序]]></title>
    <url>%2F2018%2F09%2F17%2Fsortqm%2F</url>
    <content type="text"><![CDATA[1.快速排序算法 原理： 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 根据快排的原理，我们可以知道快排是一个不断将序列分为独立的两个序列的过程，其中一部分数据要比另外一部分小，快排的重点是找到这个poit点，从而是序列很好的切分开。具体算法如下，但可以通过排序点的选取对代码进一步优化 public static void sort(int[] arr){ sort(arr, 0, arr.length-1); } public static void sort(int[] arr,int s,int e){ if (s&lt;e) { int p = getPoit(arr, s, e); sort(arr, s, p - 1); sort(arr, p + 1, e); } } public static int getPoit(int[] arr,int start,int end){//s为start ，e为end缩写 int tem=arr[start];//选取排序点 while (start&lt;end){//通过排序使start左边的值都大于tem，右边的值都大于tem while (start&lt;end&amp;&amp;arr[end]&gt;=tem)//从右边开始查找，找到小于tem处位置 end--; arr[start]=arr[end];//将其移到tem左边 while (start&lt;end&amp;&amp;arr[start]&lt;=tem)//从左边开始查找，找到大于tem处位置 start++; arr[end]=arr[start];//将其移到tem的右边 } arr[start]=tem; return start; } 2.归并排序 原理：归并排序（MERGE-SORT）是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 算法实现，第一，现将序列递归为长度为2的有序序列，由于序列是有序的，故而其合并后的序列也是有序的。其算法复杂度为O（nlogn)级别的，此处仅实现二路归并排序，有想法的朋友可以优化一下。 public static void sort(int[] arr){ sort(arr,0,arr.length-1); } public static void sort(int[] arr,int start,int end){ int mid=(start+end)/2; if (start&lt;end){ sort(arr,start,mid);//无限细分序列 sort(arr,mid+1,end); merge(arr,start,mid,end);//合并序列（由于细分序列后的数组已是有序，归并后的数组故而也是有序的） } } public static void merge(int[] arr,int start,int mid,int end){ int i=start,j=mid+1,k=0; int len=end - start + 1; int[] temp = new int[len];//辅助数组，利用空间换取移位的时间耗时 while (i&lt;=mid&amp;&amp;j&lt;=end){//由于序列不一定等长，故会存在其中一个序列没有合并完 if (arr[i]&lt;arr[j])//合并序列 temp[k++]=arr[i++]; else temp[k++]=arr[j++]; } while (i&lt;=mid)//如果i&lt;=mid即i到mid未合并完，合并该部分 temp[k++]=arr[i++]; while (j&lt;=end)//如果j&lt;=end即j到end未合并完，合并该部分 temp[k++]=arr[j++]; for ( i=0;i&lt;len;i++) //将有序数据复值到原数组中 arr[start++]=temp[i]; } 附:常见算法复杂度表]]></content>
      <categories>
        <category>Java工具</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA排序算法--直接插入排序和希尔排序]]></title>
    <url>%2F2018%2F09%2F17%2Fsortinsertshell%2F</url>
    <content type="text"><![CDATA[1.直接插入排序算法&nbsp;&nbsp;&nbsp;&nbsp;原理： 插入排序就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。&nbsp;&nbsp;&nbsp;&nbsp;具体算法实现：因此其具体算法实现即找到未排序的第一个数据（哨兵）。然后将其与前面的已排序值比较，找到插入的位置j,将j到哨兵间的元素后移一位，再将哨兵值赋给j处。其实现如下： public static void sort(int[] arr){ int len=arr.length,tem=0,j=0; for (int i=0;i&lt;len;i++){ tem=arr[i]; for ( j=i;j&gt;0&amp;&amp;arr[j-1]&gt;tem;j--){//查找i插入的位置j，即j-1处大tem arr[j]=arr[j-1];//将j到i-1处的所有元素向后挪一位 } arr[j]=tem;//将原来i处的值赋给j处 } } 2.希尔排序&nbsp;&nbsp;&nbsp;&nbsp;希尔排序就是将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序， 待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。从而减少挪位次数。&nbsp;&nbsp;&nbsp;&nbsp;其算法实现是利用增量思想，逐渐增加排序范围。 public static void sort(int[] data) { int j = 0; int temp = 0; for (int inc = data.length / 2; inc &gt; 0; inc /= 2)//每次讲增量变为原来一半 for (int i = inc; i &lt; data.length; i++) {//对每个小序列进行插入排序，当inc变为1时，对整体进行插入排序 temp = data[i]; for (j = i; j &gt;= inc&amp;&amp;temp &lt;data[j - inc]; j -= inc) {//查找插入位置i data[j] = data[j - inc];//将元素后挪 } data[j] = temp; //交换值 } } 希尔排序算法的优劣：&nbsp;&nbsp;&nbsp;&nbsp;不需要大量的辅助空间，和归并排序一样容易实现。希尔排序是基于插入排序的一种算法， 在此算法基础之上增加了一个新的特性，提高了效率。希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O( n 3/2)，希尔排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比O( )复杂度的算法快得多。并且希尔排序非常容易实现，算法代码短而简单。 此外，希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。专家们提倡，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法. 本质上讲，希尔排序算法是直接插入排序算法的一种改进，减少了其复制的次数，速度要快很多。 原因是，当n值很大时数据项每一趟排序需要移动的个数很少，但数据项的距离很长。当n值减小时每一趟需要移动的数据增多，此时已经接近于它们排序后的最终位置。 正是这两种情况的结合才使希尔排序效率比插入排序高很多。Shell算法的性能与所选取的分组长度序列有很大关系。只对特定的待排序记录序列，可以准确地估算关键词的比较次数和对象移动次数。想要弄清关键词比较次数和记录移动次数与增量选择之间的关系，并给出完整的数学分析，至今仍然是数学难题。 附:常见算法复杂度表]]></content>
      <categories>
        <category>Java工具</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA排序算法--选择排序和冒泡排序]]></title>
    <url>%2F2018%2F09%2F14%2Fsortsb%2F</url>
    <content type="text"><![CDATA[1.选择排序算法选择排序算法原理：选择排序算法就是在集合中选择最大或则最小的数，将其放在集合前列，然后循环剩下的集合数据，重复寻找最大或最小值。选择排序算法是不稳定的算法我们可以简单的依次选择剩下元素中的最小值，将其跟i处的值交换，从而达到排序的效果，不管数据如何，对于选择排序而言，它总是需要轮循n+(n-1)+(n-2)+…+2+1次，即（n+1)*n/2，算法复杂度还是O（n2)。 public static void sortSimple(int [] arr){ int len=arr.length; int tem=0; for (int i=0;i&lt;len-1;i++){ int p=i; int m=i; for (int j=len-1;j&gt;i;j--){//寻找剩下里面的最小值 if (arr[j]&lt;arr[p]) p=j; } tem=arr[p]; //将最小值交换到i处。 arr[p]=arr[i]; arr[i]=tem; } } 我们可以对选择排序算法进行优化，在选取最小值的同时，选取最大值，将其分别放置在头部和尾部,再对其剩下的部分进行轮循，虽然算法复杂度还是O（n2)级别，但优化的效果还是可以的。 public static void sort(int [] arr){ int len=arr.length; int tem=0; for (int i=0;i&lt;len-1;i++){ int p=i; int m=i; for (int j=len-1;j&gt;i;j--){ if (arr[j]&lt;arr[p])//寻找剩下里面的最小值 p=j; if (arr[j]&gt;arr[m])//寻找剩下里面的最大值 m=j; } tem=arr[p];//将最小值交换到i处。 arr[p]=arr[i]; arr[i]=tem; if (p!=m) {//避免最后的重复交换导致顺序错乱 tem = arr[len - 1];//将最大值交换到len - 1处。 arr[len - 1] = arr[m]; arr[m] = tem; len--;//没交换一次，len减1 } } } 2.冒泡排序算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;冒泡排序原理：冒泡排序算法是重复地访问未排序序列，依次比较其两个相邻的元素，如果顺序出现问题就交换其两者位置。每次轮训后，其len-i-1的值必定是未排序序列中的最大值或最小值。其算法复杂度为O（n2) 简单的排序算法算法如下 public static void sort(int [] arr){ int len=arr.length; int tem; for (int i=0;i&lt;len-1;i++) for (int j=0;j&lt;len-i-1;j++) //通过不断的比较arr j j+1处位置大小， 把大的数往后挪， // 每次都能保证将len-i个里的最大的挪到数组len-i处 //如1 4 2 3 5 2 第一次，4和2换，4和3换 5和最后一个2换 。得1 2 3 4 2 5 if (arr[j]&gt;arr[j+1]){ tem=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tem; } } 我们可以对冒泡排序算法进行一次优化，即在数组已经有序的情况下，避免不必要循环。 public static void sort(int [] arr){ int len=arr.length; int tem,count=1;//初始化值为1，确保第一次能进入循环 for (int i=0;i&lt;len-1;i++) { if (count &gt; 0) {//count大于0，说明上次轮循出现了交换，即序列可能是处于无序状态的 count=0;//赋值为零，进行下一次冒泡，并统计交换次数用于判断数组是否有序 for (int j = 0; j &lt; len - i - 1; j++) { //通过不断的比较arr j j+1处位置大小， 把大的数往后挪， // 每次都能保证将len-i个里的最大的挪到数组len-i处 //如1 4 2 3 5 2 第一次，4和2换，4和3换 5和最后一个2换 。得1 2 3 4 2 5 if (arr[j] &gt; arr[j + 1]) { count++; tem = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tem; } } }else { break;//数组已经有序，跳出循环 } } } 附:常见算法复杂度表]]></content>
      <categories>
        <category>Java工具</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[httpclient]]></title>
    <url>%2F2018%2F08%2F29%2Fhttpclient%2F</url>
    <content type="text"><![CDATA[为了应付在web项目中调用其他http或https接口的需求，本文根据 此文章 部分内容改写为以下两个发起http以及https请求的工具类 引用工具前须导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpmime --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpmime&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt; &lt;/dependency&gt; Http工具： public class HttpUtils { private static final CloseableHttpClient httpclient = HttpClients.createDefault(); private static String charset=&quot;utf-8&quot;; private static String userAgent = &quot;Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.87 Safari/537.36&quot;; private static int socketTimeout=2000; private static int connectTimeout=2000; /**参数直接附在url上 * @param url * @return String */ public static String sendGet(String url) { return excuteHttpGet(url); } /** * map参数形式 * @param url * @param params * @return String */ public static String sendGet(String url,Map&lt;String,String&gt; params){ url+=&quot;?&quot;; for (String key:params.keySet()) { url+=key+&quot;=&quot;+params.get(key)+&quot;&amp;&quot;; } return excuteHttpGet(url); } /** * 发送HttpPost请求 * @param url * @param map 参数 * @return String */ public static String sendPost(String url, Map&lt;String, String&gt; map) { // 设置参数 List&lt;NameValuePair&gt; formparams = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) { formparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue())); } // 编码 UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(formparams, Consts.UTF_8); // 取得HttpPost对象 HttpPost httpPost = new HttpPost(url); // 防止被当成攻击添加的 httpPost.setHeader(&quot;User-Agent&quot;, userAgent); // 参数放入Entity httpPost.setEntity(formEntity); return excuteHttpPost(httpPost); } /**发送HttpPost请求 * @param url * @param file 参数为文件 * @return String */ public static String sendPost(String url, File file) { HttpPost httpPost = new HttpPost(url); // 防止被当成攻击添加的 httpPost.setHeader(&quot;User-Agent&quot;, userAgent); MultipartEntityBuilder multipartEntity = MultipartEntityBuilder.create(); multipartEntity.setMode(HttpMultipartMode.BROWSER_COMPATIBLE); multipartEntity.addPart(&quot;media&quot;, new FileBody(file)); httpPost.setEntity(multipartEntity.build()); return excuteHttpPost(httpPost); } /** * 发送HttpPost请求 * @param url * @param jsonStr 参数为json字符串 * @return String */ public static String sendPost(String url, String jsonStr) { // 字符串编码 StringEntity entity = new StringEntity(jsonStr, Consts.UTF_8); // 设置content-type entity.setContentType(&quot;application/json&quot;); HttpPost httpPost = new HttpPost(url); // 防止被当成攻击添加的 httpPost.setHeader(&quot;User-Agent&quot;, userAgent); // 接收参数设置 httpPost.setHeader(&quot;Accept&quot;, &quot;application/json&quot;); httpPost.setEntity(entity); return excuteHttpPost(httpPost); } /** * 发送不带参数的HttpPost请求 * @param url * @return String */ public static String sendPost(String url) { // 得到一个HttpPost对象 HttpPost httpPost = new HttpPost(url); // 防止被当成攻击添加的 httpPost.setHeader(&quot;User-Agent&quot;, userAgent); return excuteHttpPost(httpPost); } /** * httpPost公用方法 * @param httpPost * @return */ private static String excuteHttpPost(HttpPost httpPost){ CloseableHttpResponse response = null; String result = null; RequestConfig requestConfig = RequestConfig.custom().setSocketTimeout(socketTimeout).setConnectTimeout(connectTimeout).build();//设置请求和传输超时时间 httpPost.setConfig(requestConfig); try { // 执行post请求 response = httpclient.execute(httpPost); // 得到entity HttpEntity entity = response.getEntity(); // 得到字符串 if (entity != null) { result = EntityUtils.toString(entity,charset); } } catch (IOException e) { System.out.println(&quot;IO异常：&quot;+e.getMessage()); } finally { if (response != null) { try { response.close(); } catch (IOException e) { System.out.println(&quot;关闭Response对象出现异常：&quot;+e.getMessage()); } } } return result; } private static String excuteHttpGet(String url){ String result=null; CloseableHttpResponse response = null; try { HttpGet httpGet = new HttpGet(url); httpGet.setHeader(&quot;User-Agent&quot;, userAgent); RequestConfig requestConfig = RequestConfig.custom().setSocketTimeout(socketTimeout).setConnectTimeout(connectTimeout).build();//设置请求和传输超时时间 httpGet.setConfig(requestConfig); response = httpclient.execute(httpGet); HttpEntity entity = response.getEntity(); if (entity != null) { result = EntityUtils.toString(entity,charset); } } catch (Exception e) { System.out.println(e.getMessage()); } finally { if (response != null) { try { response.close(); } catch (IOException e) { System.out.println(&quot;关闭Response对象出现异常：&quot;+e.getMessage()); } } } return result; } /** * 默认utf-8 * @param charset */ public static void setCharset(String charset) { HttpUtils.charset = charset; } public static void setUserAgent(String userAgent) { HttpUtils.userAgent = userAgent; } /** * 默认2秒 * @param socketTimeout */ public static void setSocketTimeout(int socketTimeout) { HttpUtils.socketTimeout = socketTimeout; } /** * 默认2秒 * @param connectTimeout */ public static void setConnectTimeout(int connectTimeout) { HttpUtils.connectTimeout = connectTimeout; } } Https工具类: public class HttpsUtils { private static final CloseableHttpClient httpsclient = createSSLClientDefault(); private static String charset=&quot;utf-8&quot;; private static String userAgent = &quot;Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.87 Safari/537.36&quot;; private static int socketTimeout=2000;//超时时间 private static int connectTimeout=2000; //超时时间 public static CloseableHttpClient createSSLClientDefault(){ try { SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy(){ //信任所有 public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException { return true; } }).build(); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext); return HttpClients.custom().setSSLSocketFactory(sslsf).build(); } catch (KeyManagementException e) { e.printStackTrace(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (KeyStoreException e) { e.printStackTrace(); } return HttpClients.createDefault(); } /**参数直接附在url上 * @param url * @return String */ public static String sendGet(String url) { return excuteHttpGet(url); } /** * map参数形式 * @param url * @param params * @return String */ public static String sendGet(String url,Map&lt;String,String&gt; params){ url+=&quot;?&quot;; for (String key:params.keySet()) { url+=key+&quot;=&quot;+params.get(key)+&quot;&amp;&quot;; } return excuteHttpGet(url); } /** * 发送HttpPost请求 * @param url * @param map 参数 * @return String */ public static String sendPost(String url, Map&lt;String, String&gt; map) { // 设置参数 List&lt;NameValuePair&gt; formparams = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) { formparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue())); } // 编码 UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(formparams, Consts.UTF_8); // 取得HttpPost对象 HttpPost httpPost = new HttpPost(url); // 防止被当成攻击添加的 httpPost.setHeader(&quot;User-Agent&quot;, userAgent); // 参数放入Entity httpPost.setEntity(formEntity); return excuteHttpPost(httpPost); } /**发送HttpPost请求 * @param url * @param file 参数为文件 * @return String */ public static String sendPost(String url, File file) { HttpPost httpPost = new HttpPost(url); // 防止被当成攻击添加的 httpPost.setHeader(&quot;User-Agent&quot;, userAgent); MultipartEntityBuilder multipartEntity = MultipartEntityBuilder.create(); multipartEntity.setMode(HttpMultipartMode.BROWSER_COMPATIBLE); multipartEntity.addPart(&quot;media&quot;, new FileBody(file)); httpPost.setEntity(multipartEntity.build()); return excuteHttpPost(httpPost); } /** * 发送HttpPost请求 * @param url * @param jsonStr 参数为json字符串 * @return String */ public static String sendPost(String url, String jsonStr) { // 字符串编码 StringEntity entity = new StringEntity(jsonStr, Consts.UTF_8); // 设置content-type entity.setContentType(&quot;application/json&quot;); HttpPost httpPost = new HttpPost(url); // 防止被当成攻击添加的 httpPost.setHeader(&quot;User-Agent&quot;, userAgent); // 接收参数设置 httpPost.setHeader(&quot;Accept&quot;, &quot;application/json&quot;); httpPost.setEntity(entity); return excuteHttpPost(httpPost); } /** * 发送不带参数的HttpPost请求 * @param url * @return String */ public static String sendPost(String url) { // 得到一个HttpPost对象 HttpPost httpPost = new HttpPost(url); // 防止被当成攻击添加的 httpPost.setHeader(&quot;User-Agent&quot;, userAgent); return excuteHttpPost(httpPost); } /** * httpPost公用方法 * @param httpPost * @return */ private static String excuteHttpPost(HttpPost httpPost){ CloseableHttpResponse response = null; String result = null; RequestConfig requestConfig = RequestConfig.custom().setSocketTimeout(socketTimeout).setConnectTimeout(connectTimeout).build();//设置请求和传输超时时间 httpPost.setConfig(requestConfig); try { // 执行post请求 response = httpsclient.execute(httpPost); // 得到entity HttpEntity entity = response.getEntity(); // 得到字符串 if (entity != null) { result = EntityUtils.toString(entity,charset); } } catch (IOException e) { System.out.println(&quot;IO异常：&quot;+e.getMessage()); } finally { if (response != null) { try { response.close(); } catch (IOException e) { System.out.println(&quot;关闭Response对象出现异常：&quot;+e.getMessage()); } } } return result; } private static String excuteHttpGet(String url){ String result=null; CloseableHttpResponse response = null; try { HttpGet httpGet = new HttpGet(url); httpGet.setHeader(&quot;User-Agent&quot;, userAgent); RequestConfig requestConfig = RequestConfig.custom().setSocketTimeout(socketTimeout).setConnectTimeout(connectTimeout).build();//设置请求和传输超时时间 httpGet.setConfig(requestConfig); response = httpsclient.execute(httpGet); HttpEntity entity = response.getEntity(); if (entity != null) { result = EntityUtils.toString(entity,charset); } } catch (Exception e) { System.out.println(e.getMessage()); } finally { if (response != null) { try { response.close(); } catch (IOException e) { System.out.println(&quot;关闭Response对象出现异常：&quot;+e.getMessage()); } } } return result; } /** * 默认utf-8 * @param charset */ public static void setCharset(String charset) { HttpsUtils.charset = charset; } public static void setUserAgent(String userAgent) { HttpsUtils.userAgent = userAgent; } /** * 默认2秒 * @param socketTimeout */ public static void setSocketTimeout(int socketTimeout) { HttpsUtils.socketTimeout = socketTimeout; } /** * 默认2秒 * @param connectTimeout */ public static void setConnectTimeout(int connectTimeout) { HttpsUtils.connectTimeout = connectTimeout; } } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>Java工具</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件处理类]]></title>
    <url>%2F2018%2F08%2F28%2Ffileutil%2F</url>
    <content type="text"><![CDATA[1.生成文件名，避免文件重复 public static String getRandomFileName() { // 生成随机文件名：当前年月日时分秒+五位随机数（为了在实际项目中防止文件同名而进行的处理） int rannum = (int) (r.nextDouble() * (99999 - 10000 + 1)) + 10000; // 获取随机数 String nowTimeStr = sDateFormat.format(new Date()); // 当前时间 return nowTimeStr + rannum; } 2.删除文件或目录 public static void deleteFile(String storePath) { File file = new File( storePath); if (file.exists()) { if (file.isDirectory()) { File files[] = file.listFiles(); for (int i = 0; i &lt; files.length; i++) { files[i].delete(); } } file.delete(); } } 3.读取文件内容到string中 public static String readFileToStr(String path){ StringBuffer stringBuffer=new StringBuffer(); try { BufferedReader in = new BufferedReader(new FileReader(path)); String line= in.readLine(); while (line!=null){ stringBuffer.append(line); line=in.readLine(); } in.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return stringBuffer.toString(); } 4.读取配置文件内容到map，可通过map读取对应配置 public static HashMap&lt;String, String&gt; readFiletoMap(String path) { HashMap&lt;String, String&gt; propeMap = new HashMap&lt;String, String&gt;(); String[] tem; String line=&quot;&quot;; try { BufferedReader in = new BufferedReader(new FileReader(path)); line = in.readLine(); while (line != null) { tem=line.split(&quot;=&quot;); if (tem.length&gt;1) propeMap.put(tem[0],tem[1]); line = in.readLine(); } in.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return propeMap; } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>Java工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DES加密工具]]></title>
    <url>%2F2018%2F08%2F28%2Fdesutil%2F</url>
    <content type="text"><![CDATA[本工具采用的是DES SHA1PRNG 加密，如有兴趣，读者可由此自定义其他加密工具。具体可看代码注释 import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.InvalidKeyException; import java.security.Key; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import javax.crypto.*; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; /** * DESUtils 先采用BASE64Encoder对字符串进行处理，避免字符问题。 * 再采用des 标准的SHA1PRNG加密方法进行加密 */ public class DESUtils { private static Key key; private static String KEY_STR = &quot;webapp&quot;;//加密秘钥,请自定义值 private static String charset = &quot;UTF-8&quot;; private static String type = &quot;DES&quot;; //加密标准 private static String method=&quot;SHA1PRNG&quot;; //加密方法 private static Cipher cipher; //用于加解密操作的对象 //初始化key cipher static { try { KeyGenerator generator = KeyGenerator.getInstance(type); //获取秘钥对象 SecureRandom secureRandom = SecureRandom.getInstance(method);//获取加密算法的强随机数对象 secureRandom.setSeed(KEY_STR.getBytes());//根据key_str生成强随机数 generator.init(secureRandom);//初始化秘钥对象 key = generator.generateKey();//生成key generator = null; cipher= Cipher.getInstance(type);//获取cipher cipher.init(Cipher.ENCRYPT_MODE, key);//根据key初始化cipher } catch (NoSuchPaddingException e) { throw new RuntimeException(e); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } catch (InvalidKeyException e) { throw new RuntimeException(e); } } //获取加密后的字符串 public static String getEncryptString(String str) { BASE64Encoder base64encoder = new BASE64Encoder(); byte[] bytes = new byte[0]; try { bytes = str.getBytes(charset); byte[] doFinal = new byte[0]; doFinal = cipher.doFinal(bytes); return base64encoder.encode(doFinal); } catch (IllegalBlockSizeException e) { throw new RuntimeException(e); } catch (BadPaddingException e) { throw new RuntimeException(e); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } } //获取加密后的字符串 将字符串解密 public static String getDecryptString(String str) { BASE64Decoder base64decoder = new BASE64Decoder(); try { byte[] bytes = base64decoder.decodeBuffer(str); byte[] doFinal = cipher.doFinal(bytes); return new String(doFinal, charset); } catch (IllegalBlockSizeException e) { throw new RuntimeException(e); } catch (BadPaddingException e) { throw new RuntimeException(e); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>Java工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seo工具]]></title>
    <url>%2F2018%2F08%2F28%2Fsitemaputil%2F</url>
    <content type="text"><![CDATA[Sitemaps定义：Google、雅虎、和微软都支持一个被称为xml网站地图（xml Sitemaps）的协议，而百度Sitemap是指百度支持的收录标准，在原有协议上做出了扩展。百度sitemap的作用是通过Sitemap告诉百度蜘蛛全面的站点链接，优化自己的网站。百度Sitemap分为三种格式：txt文本格式、xml格式、Sitemap索引格式。 具体实现，请查看代码注释： /**使用本工具请加载jar包org.dom4j * 使用方法请看main方法 * sitemap文件例子可看： * https://www.zulily.com/sitemap.xml */ public class SitemapUtil { //xml文件头xmlns属性值：例&lt;sitemapindex xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt; private static String xmlns =&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;; //存放文件路径：可为/aaa/bbb/等，最后位必须带/符号 private static final String filePath=&quot;E:/aa/&quot;; //private static final String filePath=System.getenv(&quot;SITE_MAP_PATH&quot;);//可通过环境变量拿 //生成xml文件的编码 private static final String encode=&quot;gbk&quot;; //以上值可按情况修改 //用于记录子sitemap文件名，最后用于生成主sitemap文件 private static ArrayList&lt;String&gt; childSitemaps=new ArrayList&lt;String&gt;(); //先声明节点 private static Element urlElement; private static Element locElement; private static Element freqElement; private static Element priElement; /** * 使用示例 * @param args */ public static void main(String[] args){ //初始化document，并赋予带namespace的根节点 Document document=new DefaultDocument(); //xmlns即命名空间 Element root=document.addElement(&quot;urlset&quot;,xmlns); document.setRootElement(root); //写入n个子sitemap文件的示例======================== boolean isOk=false; for (int i=1;i&lt;20;i++) { //构建document for (int j = 0; j &lt; 50000; j++) { createChildDom(root, &quot;https://www.scut.edu.cn/new/gasdvgaswcsfes&quot; + j, &quot;weekly&quot;, &quot;0.9&quot;); } //写入文件 isOk = SitemapUtil.createChoildSitemap(document, &quot;sitemap-child-&quot;+i+&quot;.xml&quot;); if (!isOk){ //生成出错 } } //===================================================== //写入主sitemap isOk= SitemapUtil.createMainSitemap(); if (!isOk){ //生成出错 } } /** * 创建主sitemap文件，该方法应该在生成所有子sitemap文件调用。 */ public static boolean createMainSitemap(){ Document document=new DefaultDocument(); Element root=document.addElement(&quot;sitemapindex&quot;,xmlns); for (int i=0;i&lt;childSitemaps.size();i++){ Element sitemap=root.addElement(&quot;sitemap&quot;); Element loc=sitemap.addElement(&quot;loc&quot;); loc.setText(childSitemaps.get(i)); } try { writeDocument(&quot;sitemap.xml&quot;,document); } catch (IOException e) { e.printStackTrace(); return false; }finally { //清空根节点下的所有内容 if (document.hasContent()) document.clearContent(); } return true; } public static boolean createChoildSitemap(Document document ,String filename){ try { writeDocument(filename,document); childSitemaps.add(filename); } catch (IOException e) { e.printStackTrace(); return false; }finally { //清空根节点下的所有内容 if (document.hasContent()&amp;&amp;document.getRootElement().hasContent()) document.getRootElement().clearContent(); } return true; } /** * 将document写入 filePath目录下的fileName文件里 * @param fileName * @param document * @throws IOException */ private static void writeDocument( String fileName,Document document) throws IOException { File file=new File(filePath); document.setXMLEncoding(encode); recursionMkDir(file); OutputStreamWriter outputStreamWriter=new OutputStreamWriter(new FileOutputStream(new File(filePath+fileName))); document.write(outputStreamWriter); //如果outputStreamWriter未关闭，则关闭outputStreamWriter if (outputStreamWriter!=null) outputStreamWriter.close(); } /** * 创建子sitemap的节点，并将其挂载到root节点 * 例：&lt;url&gt; * &lt;loc&gt;https://www.zulily.com/baby-boy-outerwear&lt;/loc&gt; * &lt;changefreq&gt;daily&lt;/changefreq&gt; 值只能为always, hourly, daily, weekly, monthly, yearly及never * &lt;priority&gt;0.4&lt;/priority&gt;数值为0到1.0，最高为1.0，一般首页的priority最高为1.0 * &lt;/url&gt; * @param root * @param url * @param changefreq * @param priority */ private static void createChildDom(Element root,String url,String changefreq ,String priority){ urlElement=root.addElement(&quot;url&quot;); locElement=urlElement.addElement(&quot;loc&quot;); freqElement=urlElement.addElement(&quot;changefreq&quot;); priElement=urlElement.addElement(&quot;priority&quot;); locElement.setText(url); freqElement.setText(changefreq); priElement.setText(priority); } //递归创建目录 private static void recursionMkDir(File file) { if (file.getParentFile().exists()) { file.mkdir(); } else { recursionMkDir(file.getParentFile()); file.mkdir(); } } } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>Java工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证码生成工具]]></title>
    <url>%2F2018%2F08%2F28%2Fcodeutil%2F</url>
    <content type="text"><![CDATA[本验证码生成采用的是Google提供的第三方KAPTCHA服务，使用及其方便，使用步骤分为以下三步：1.添加依赖 在pom.xml文件中添加 &lt;dependency&gt; &lt;groupId&gt;com.google.code.kaptcha&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; 2.在web.xml中配置servlet,可根据注释酌情配置 &lt;servlet&gt; &lt;!-- 生成图片的Servlet --&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt; &lt;!-- 是否有边框 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.border&lt;/param-name&gt; &lt;param-value&gt;no&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 字体颜色 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.font.color&lt;/param-name&gt; &lt;param-value&gt;red&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 图片宽度 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.image.width&lt;/param-name&gt; &lt;param-value&gt;135&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 使用哪些字符生成验证码 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.char.string&lt;/param-name&gt; &lt;param-value&gt;ACDEFHKPRSTWX345679&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 图片高度 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.image.height&lt;/param-name&gt; &lt;param-value&gt;50&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 字体大小 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.font.size&lt;/param-name&gt; &lt;param-value&gt;43&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 干扰线的颜色 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.noise.color&lt;/param-name&gt; &lt;param-value&gt;black&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 字符个数 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.char.length&lt;/param-name&gt; &lt;param-value&gt;4&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 使用哪些字体 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.font.names&lt;/param-name&gt; &lt;param-value&gt;Arial&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;url-pattern&gt;/Kaptcha&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3.为了方便使用，此处已经将判断验证码写成了方法。前端传进来的参数验证码key必须为verifyCodeActual public static boolean checkVerifyCode(HttpServletRequest request) { String verifyCodeExpected = (String) request.getSession().getAttribute( com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY); String verifyCodeActual = request.getParameter(&quot;verifyCodeActual&quot;); if (verifyCodeActual == null || !verifyCodeActual.equalsIgnoreCase(verifyCodeExpected)) { return false; } return true; } 4.前端部分代码如下 (仍需自定义填写验证码的输入框，并将其参数以verifyCodeActual为key传给后端： &lt;img sr=&quot;/Kaptcha&quot; /&gt; &lt;!-- src 为web.xml配置的拦截路径 --&gt; function changeVerifyCode(img) { img.src = &quot;../Kaptcha?&quot; + Math.floor(Math.random() * 100); } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>Java工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5加密工具]]></title>
    <url>%2F2018%2F08%2F28%2Fmd5%2F</url>
    <content type="text"><![CDATA[public static String getMd5(String str) throws NoSuchAlgorithmException { char hex[] = { //用于混淆 可自定义 &apos;1&apos;, &apos;2&apos;, &apos;o&apos;, &apos;3&apos;, &apos;h&apos;, &apos;w&apos;, &apos;s&apos;, &apos;2&apos;, &apos;2&apos;, &apos;q&apos; , &apos;1&apos;, &apos;j&apos;, &apos;5&apos;, &apos;3&apos;, &apos;2&apos;, &apos;w&apos;, &apos;s&apos;, &apos;2&apos;, &apos;2&apos;, &apos;q&apos;, &apos;b&apos;, &apos;l&apos;, &apos;e&apos;, &apos;j&apos;, &apos;s&apos;,&apos;a&apos; }; MessageDigest messageDigest = MessageDigest.getInstance(&quot;MD5&quot;);//获取MD5实例 messageDigest.update(str.getBytes());//利用str 的char数组 更新 MD5 byte [] digest= messageDigest.digest();//获取str 摘要 int len = digest.length; char[] chars = new char[len]; int k = 0; for (int i = 0; i &lt; len; i++) { byte num = digest[i]; chars[k++] = hex[ num&amp; 25]; //num &amp; 25 将 num压缩到25（小于hex的长度）以内，并以hex中的char替换混淆 } return new String(chars); } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>Java工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 斐波那契数列问题]]></title>
    <url>%2F2018%2F08%2F21%2FJumpFloor%2F</url>
    <content type="text"><![CDATA[1、斐波那契数列 （Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*） 代码实现如下： // 斐波那契数列的java实现 public static int Fibonacci(int n) { int last=1,latter=1,result=0; //用于缓存f(n-1) f(n-2) if (0==n) return 0; else if (1==n||2==n) return 1; else { for (int i=3;i&lt;=n;i++){ result=last+latter; //计算f(n) last=latter;//更新f(n-2) latter=result; //更新f(n-1) } return result; } } 2、一只青蛙一次可以跳上1级台阶，也可以跳上2级。 求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 用递推可知其结果为斐波那契数列f(n)=f(n-1)+f(n-2) public int JumpFloor(int n) { int last=1,latter=2,result=0; //用于缓存f(n-1) f(n-2) if (0==n) return 0; else if (1==n) return 1; else if(2==n) return 2; else { for (int i=3;i&lt;=n;i++){ result=last+latter; //计算f(n) last=latter;//更新f(n-2) latter=result; //更新f(n-1) } return result; } } 3、附加：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 static int jumpFloorII(int number) {//罗列各项，寻找规律，可知f(n)=2的n-1次方 int result=1; return result&lt;&lt;(number-1);//将乘法优化为位运算 } 4、我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？罗列各项，寻找规律，递推可知其结果为斐波那契数列f(n)=f(n-1)+f(n-2) int rectCover(int target) { int last=1,latter=2,result=0; //用于缓存f(n)=f(n-1)+f(n-2) if (1==target) return 1; else if (2==target) return 2; else { for (int i=3;i&lt;=target;i++){ result=last+latter; //计算f(n) last=latter; //更新f(n-2) latter=result; //更新f(n-1) } return result; } } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 重排数组]]></title>
    <url>%2F2018%2F08%2F21%2FreOrderArray%2F</url>
    <content type="text"><![CDATA[1、输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 public void reOrderArray(int [] array) { int len=array.length; int[] arr=array.clone(); //拷贝一份数组 int p=0; for (int i=0;i&lt;len;i++){//遍历拷贝数组，先插入奇数 if ((arr[i]&amp;1)==1){ array[p++]=arr[i]; } } for (int i=0;i&lt;len;i++){//遍历拷贝数组，插入偶数 if ((arr[i]&amp;1)==0){ array[p++]=arr[i]; } if (p==len)//所有元素已经插入后，无需再继续遍历 break; } } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 统计二进制1与指数的实现]]></title>
    <url>%2F2018%2F08%2F21%2Fmath%2F</url>
    <content type="text"><![CDATA[1、输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 static int NumberOf1(int n) { //例如10101 int count=0; while (n!=0){ count++; n=n&amp;(n-1); //除去末尾1 10100&amp;10011=10000 } return count; } 2、给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 public double Power(double base, int exponent) throws Exception { int num=exponent; double result=1; if (exponent&lt;0) {//当指数为负数时，转为正数 exponent = -exponent; if (base==0) throw new Exception(&quot;base 不能等于0&quot;); } while (exponent!=0){ if ((exponent&amp;1)==1)//当末尾为零时 result*=base; base*=base;//倍乘（二进制，每隔差一位为2倍，故应倍乘 exponent=exponent&gt;&gt;1;//乘或倍乘后右移一位， } return num&gt;0?result:1/result; //当指数为负时，返回1/result。否则返回result } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 输出倒数第k个结点以及逆转指针]]></title>
    <url>%2F2018%2F08%2F21%2FlistNode%2F</url>
    <content type="text"><![CDATA[1、输入一个链表，输出该链表中倒数第k个结点。 public ListNode FindKthToTail(ListNode head,int k) { ListNode tem=head;//缓根节点 while (k&gt;0&amp;tem!=null) { //tem 先行到k处 tem = tem.next; k--; } if(k!=0) return null; while (tem!=null){//head和tem一起向下走，当tem是尾节点。head所在位置恰好与tem相差k head=head.next; tem=tem.next; } return head; } 2、输入一个链表，反转链表后，输出新链表的表头。 public ListNode ReverseList(ListNode head) { ListNode buf=head; //buf&gt;listNode&gt; 1》2,》3,》4 ListNode pre=buf; //pre&gt;buf&gt;listNode&gt; 1》2,》3,》4 if (head==null) return null; while (head.next!=null){ //判断节点是否还有下一个元素 buf=head.next; // buf&gt;2&gt;3&gt;4 head.next=buf.next;// listNode&gt;1&gt;3&gt;4 buf.next=pre;//buf&gt;2&gt;1&gt;3&gt;4 pre=buf;//pre&gt;2&gt;1&gt;3&gt;4 } return buf; } 3、输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 public static ListNode Merge(ListNode list1,ListNode list2) { ListNode head=list1;//记录头部节点 ListNode tem; ListNode node; while (list2!=null){// 以list1为链表，将list2插入list1，故判断list2是否为空 if (list1.next==null){//当list1已到达尾节点时，避免空指针 if (list1.val&lt;=list2.val) {//list1值小于list2值，则list2后续节点皆大于list2。故可直接将所有节点插入，跳出循环 list1.next = list2; break; } else {//否则将list2的值插入list1前 node=new ListNode(list1.val); list1.next=node; list1.val=list2.val; list1=list1.next; list2=list2.next; } } if (list1.val&lt;=list2.val){ if (list1.next.val&gt;list2.val) {//判断是否合适插入点 tem = list1.next; node = new ListNode(list2.val); list1.next = node; node.next = tem; list1=list1.next; list2 = list2.next; } else//否则继续寻找合适插入点 list1=list1.next; }else {//互换值，确保list1&lt;list2 （尚可以优化，按 list1.next.val&lt;list2.val） int num=list1.val; list1.val=list2.val; list2.val=num; } } return head; } 备注： class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 树的遍历]]></title>
    <url>%2F2018%2F08%2F21%2FtreeTraver%2F</url>
    <content type="text"><![CDATA[1、利用递归的方式获取树的前序遍历结果 //获取树的前序遍历 public static String preTraver(TreeNode root){ if (root!=null) { re += root.val; if (root.left != null) preTraver(root.left); if (root.right != null) preTraver(root.right); } return re; } 2、 利用递归的方式获取树的中序遍历结果 //获取树的中序遍历 public static String medTraver(TreeNode root){ if (root!=null) { if (root.left != null) medTraver(root.left); re += root.val; if (root.right != null) medTraver(root.right); } return re; } 3、利用递归的方式获取树的后序遍历结果 //获取树的后序遍历 public static String aftTraver(TreeNode root){ if (root!=null) { if (root.left != null) preTraver(root.left); if (root.right != null) preTraver(root.right); re += root.val; } return re; } 4、利用队列实现层次遍历 //获取树的层次遍历 public static String levelTraver(TreeNode root){ Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;TreeNode&gt;(); TreeNode node; if (root!=null) queue.offer(root); while (!queue.isEmpty()){ node=queue.poll(); re+=node.val; if (node.left!=null) queue.offer(node.left); if (node.right!=null) queue.offer(node.right); } return re; } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 树问题]]></title>
    <url>%2F2018%2F08%2F21%2Ftreeutil%2F</url>
    <content type="text"><![CDATA[1、输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） //如果root2为root1的子树，则root2的前序遍历字段必为root1的子串 public boolean HasSubtree(TreeNode root1,TreeNode root2) { if (root1==null||root2==null)//如果为空，则不必判断 return false; String str1=preTraver(root1);//root1的前序遍历字段 re=&quot;&quot;;//置空前序遍历方法的结果串 String str2=preTraver(root2);//root2的前序遍历字段 if (str1.contains(str2)) //str1包含str2，则root2为root1的子树 return true; else return false; } 2、操作给定的二叉树，将其变换为源二叉树的镜像。 /**操作给定的二叉树，将其变换为源二叉树的镜像。 * 可以用递归的方法将所有的节点的左右节点换位即可 * @param root */ public static void Mirror(TreeNode root) { if (root==null) return; tem=root.left;//缓存左子树 root.left=root.right;//将右子树赋值给左子树 root.right=tem;//将左子树赋值给右子树 if (root.left!=null) Mirror(root.left);//递归左子树 if (root.right!=null) Mirror(root.right);//递归右子树 } 备注： TreeNode类： public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } //获取树的前序遍历 public static String preTraver(TreeNode root){ if (root!=null) { re += root.val; if (root.left != null) preTraver(root.left); if (root.right != null) preTraver(root.right); } return re; } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 用两个栈实现队列]]></title>
    <url>%2F2018%2F08%2F19%2FStackToQueue%2F</url>
    <content type="text"><![CDATA[题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 用栈实现队列的原理是双重否定，经过两次后进先出的队列，其数据也就转换为了先进后出的队列。实现的要点在于区分何时将数据从栈转移到另一个栈Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();//用来进行push操作 Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();//用来进行pop操作 public void push(int node) { stack1.push(node); } public int pop() { if (stack2.isEmpty()){//当stack2为空时，尝试将stack1的所有元素移到stack2. //将stack1的所有元素移到stack2.由于经过stack1和Stack2后，后进先出的,变为先进先出的队列 while (!stack1.isEmpty()){ stack2.push(stack1.pop()); } } return stack2.pop(); } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 旋转数组的最小数字]]></title>
    <url>%2F2018%2F08%2F19%2FminNumberInRotateArray%2F</url>
    <content type="text"><![CDATA[题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 ####### 题目的要点在于判定数组从何处旋转，即array[start]&gt;array[start+1]处。只需循环到符合条件，便可认为其为最小值。该题目还需注意两个边界值，一是最大索引处即start+1要小于等于数组长度，一是为0时，直接返回0，1时直接返回1。 public int minNumberInRotateArray(int [] array) { int start=0; int end=array.length-1; int mid; if (end&lt;0)//长度为零直接返回0 return 0; if (end==0)//长度为1直接返回array[0]处数值 return array[0]; while (start&lt;end){//循环数组 //当array[start]&gt;array[start+1] 由有序旋转数组定义可知，array[start+1]即为最小值。array[start]为最大值 if (array[start]&gt;array[start+1]) return array[start+1]; start++; } return 0; } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】重建二叉树]]></title>
    <url>%2F2018%2F08%2F19%2FreConstructBinaryTree%2F</url>
    <content type="text"><![CDATA[题目描述: 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 递归实现 根据前序遍历和中序遍历还原二叉树的一个要点是，前序遍历的每一个节点可以当成根节点处理，叶子节点即为子节点为空的根节点。而根据前序遍历定义的根节点的值在中序遍历所在索引的左边即为左子树，右边即为右子树。 public TreeNode reConstructBinaryTree(int [] pre,int [] in) { int len=in.length; // 用map是因为其查找效率均衡，在数据量较大时较优.hashMap默认因子为0.75 HashMap&lt;Integer,Integer&gt; map= new HashMap&lt;Integer, Integer&gt;(len*4/3+2); for(int i=0;i&lt;len;i++){ map.put(in[i],i); } return reBulid(pre,0,len-1,in,0,len-1,map); } //递归创建各子树 public TreeNode reBulid(int [] pre, int prestart, int preend, int [] in, int instart, int inend, HashMap&lt;Integer,Integer&gt; map){ if(prestart &gt; preend || instart&gt; inend)//说明已无左节点或有节点 return null; TreeNode root = new TreeNode(pre[prestart]);//新建子树的根节点 //对中序数组进行输入边界的遍历 //查找子树根节点位置,用map是因为其查找效率均衡，在数据量较大时较优 int i=map.get(pre[prestart]); //递归构建左子树 //中序遍历的根节点的左边为左子树，并求出器索引位置，前序遍历的前索引位即是左子树，明确边界 root.left = reBulid(pre,prestart+1,prestart+i-instart,in,instart,i-1,map); //递归构建右子树 //中序遍历的根节点的右边为右子树，并求出其索引位置，前序遍历的后end-索引个即是右子树，明确边界 root.right = reBulid(pre,prestart+i+1-instart,preend,in,i+1,inend,map); return root; } Coding Blog &nbsp;&nbsp;&nbsp; Github Blog]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 从尾到头打印链表]]></title>
    <url>%2F2018%2F08%2F19%2FprintListFromTailToHead%2F</url>
    <content type="text"><![CDATA[题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 1.利用递归实现 //递归实现 public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) { if (listNode!=null){ this.printListFromTailToHead(listNode.next);//先递归到末尾元素 arrayList.add(listNode.val);//依次将元素添加进数组 } return arrayList; } 2.利用栈的先进后出实现 //利用栈的先进后出 public ArrayList&lt;Integer&gt; printListFromTailToHead1(ListNode listNode) { Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); while (listNode!=null){ //利用栈的先进后出 将ListNode缓存进栈中 stack.push(listNode.val); listNode=listNode.next; } while (!stack.isEmpty()){//当栈非空时 arrayList.add(stack.pop());//将元素出栈，并添加到数组里。 } return arrayList; } 3.先将指针逆转，再一次添加到链表 //逆转指针 public static ArrayList&lt;Integer&gt; printListFromTailToHead2(ListNode listNode) {//假有四个节点，方向1》2,》3,》4 listNode &gt;1 ListNode buf=listNode; //buf&gt;listNode&gt; 1》2,》3,》4 ListNode pre=buf; //pre&gt;buf&gt;listNode&gt; 1》2,》3,》4 if (listNode==null) return arrayList; while (listNode.next!=null){ //判断节点是否还有下一个元素 buf=listNode.next; // buf&gt;2&gt;3&gt;4 listNode.next=buf.next;// listNode&gt;1&gt;3&gt;4 buf.next=pre;//buf&gt;2&gt;1&gt;3&gt;4 pre=buf;//pre&gt;2&gt;1&gt;3&gt;4 } //buf&gt;4&gt;3&gt;2&gt;1 while (buf!=null){ arrayList.add(buf.val); buf=buf.next; } return arrayList; } &lt;center&gt;[Coding Blog](http://kangtian.coding.me) &amp;nbsp;&amp;nbsp;&amp;nbsp; [Github Blog ](http://pankangtian.github.io/) &lt;/center&gt;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 字符串替换]]></title>
    <url>%2F2018%2F08%2F17%2Fstringreplace%2F</url>
    <content type="text"><![CDATA[题目： 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 1、 为了减少插入时字符串的移位消耗，可生成一个对象去进行append操作，而不是在原来字符串进行插入操作； 为了减少不必要的append，可以通过start和end确定要进行append的子串，通过判断是否为空格进行append的时机； public static String replaceSpace(StringBuffer str) { StringBuffer stringBuffer=new StringBuffer(); int start=0; int end=0; int lenght=str.length(); while (end&lt;lenght){ //计算从何处开始append，减少append次数 if (str.charAt(end)!=&apos; &apos;){ end++; }else {//当char 等于空格时开始替换 stringBuffer.append(str.substring(start,end)).append(&quot;%20&quot;); end++; start=end; } } stringBuffer.append(str.substring(start,end));//最后一次，将末尾start,end的子串插入 return stringBuffer.toString(); } 2、 不新生成对象，采用统计空格数，重新赋值字符串长度，然后采用从尾部赋值的操作方式，减少移位，提升效率。 public static String replaceSpace2(StringBuffer str) { int count=0; int oldlen=str.length(); for (int i=0;i&lt;oldlen;i++){//计算空格数 if (str.charAt(i)==&apos; &apos;) count++; } int newlen=oldlen+count*2; //计算新字符串长度 str.setLength(newlen); for (int i=oldlen-1;i&gt;=0;i--){//从尾开始进行赋值操作，避免从头部操作时的char的移位 char data=str.charAt(i); if (data!=&apos; &apos;){//如果不等于空格则直接赋值 str.setCharAt(--newlen,data); } else {//如果等于空格，则赋值%20 str.setCharAt(--newlen,&apos;0&apos;); str.setCharAt(--newlen,&apos;2&apos;); str.setCharAt(--newlen,&apos;%&apos;); } } return str.toString(); } &lt;center&gt;[Coding Blog](http://kangtian.coding.me) &amp;nbsp;&amp;nbsp;&amp;nbsp; [Github Blog ](http://pankangtian.github.io/) &lt;/center&gt;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【剑指offer】 二维数组中的查找]]></title>
    <url>%2F2018%2F08%2F16%2Farrayfind%2F</url>
    <content type="text"><![CDATA[题目： 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1、在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路。由于是有序数组，所以左下角的数正好是一个很好的中间数，它的上都小于它，右都大于它，当target大于它时，令其右移，小于时左移。 public boolean Find(int target, int [][] array) { int colsize=array[0].length; int row=array.length-1; int col=0; while (col&lt;colsize&amp;row&gt;=0){ if (target&gt;array[row][col]){ //如果大于，则右移 col++; }else if (target&lt;array[row][col]){ //如果大于，则上移 row--; }else { return true; } } return false; } 2、 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路： 由于是有序数组，所以可以从第一行开始使用二分查找遍历。 public boolean binFind(int target, int [][] array) { int cols=array[0].length; int rows=array.length; int end=cols-1; for (int i=0;i&lt;rows;i++){//循环没一行 int start=0; while (start&lt;=end){ 对每一行进行二分查找 int mid=(start+end)/2; if (target&lt;array[i][mid]){ end=mid-1; }else if (target&gt;array[i][mid]){ start=mid+1; } else { return true; } } } return false; } &lt;center&gt;[Coding Blog](http://kangtian.coding.me) &amp;nbsp;&amp;nbsp;&amp;nbsp; [Github Blog ](http://pankangtian.github.io/) &lt;/center&gt;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
</search>
